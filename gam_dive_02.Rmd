---
title: "GAMをもう少し理解したい②"
output: html_document
---

前回の続きです。 `gam.fit()` から。

### GAMの実装
#### gam.fit()
それでは続いて `gam.fit` の中身を覗いてみましょう。

```{r}
### gam.fit は x, y に加えて smooth.frame を受け取る。これは gam で作った mf で、中身は平滑化に関する情報を持った data.frame 
function (x, y, smooth.frame, weights = rep(1, nobs), start = NULL, 
    etastart = NULL, mustart = NULL, offset = rep(0, nobs), family = gaussian(), 
    control = gam.control()) 
{
    ### 列名
    ynames <- if (is.matrix(y)) 
        dimnames(y)[[1]]
    else names(y)
    xnames <- dimnames(x)[[2]]

    ### データの行数、列数
    nobs <- NROW(y)
    nvars <- ncol(x)

    ## その他の gam.control オプション
    maxit <- control$maxit
    bf.maxit <- control$bf.maxit
    epsilon <- control$epsilon
    bf.epsilon <- control$bf.epsilon
    trace <- control$trace

    ### digits, weigths, offset
    digits <- -log10(epsilon) + 1
    if (is.null(weights)) 
        weights <- rep.int(1, nobs)
    if (is.null(offset)) 
        offset <- rep.int(0, nobs)
    
    ### family に関するパラメータ
    variance <- family$variance
    dev.resids <- family$dev.resids
    aic <- family$aic
    linkinv <- family$linkinv
    mu.eta <- family$mu.eta
    if (!is.function(variance) || !is.function(linkinv)) 
        stop("illegal `family' argument")
    valideta <- family$valideta
    if (is.null(valideta)) 
        valideta <- function(eta) TRUE
    validmu <- family$validmu
    if (is.null(validmu)) 
        validmu <- function(mu) TRUE
    eval(family$initialize)
    if (is.null(mustart)) {
        eval(family$initialize)
    }
    else {
        mukeep <- mustart
        eval(family$initialize)
        mustart <- mukeep
    }
    ### eta の初期値
    eta <- if (!is.null(etastart)) 
        etastart
    
    ### エラーチェック
    else if (!is.null(start)) 
        if (length(start) != nvars) 
            stop("Length of start should equal ", nvars, " and correspond to initial coefs for ", 
                deparse(xnames))
        else {
            coefold <- start
            offset + as.vector(if (NCOL(x) == 1) 
                x * start
            else x %*% start)
        }
    else family$linkfun(mustart)

    ### mu の初期値
    mu <- linkinv(eta)
    if (!(validmu(mu) && valideta(eta))) 
        stop("Can't find valid starting values: please specify some")

    ### デビアンス（残差平方和）
    new.dev <- sum(dev.resids(y, mu, weights))
```

ここまでは関数に渡されたオプションを元に処理を進めていますが、以降のプロセスで `gam` 特有の処理が行われています。まずは `smoothers` の取り出しです。

```{r}
### smoothers が指定されている場合に smoother を抽出する
### 今回のケースでは s が入る
a <- attributes(attr(smooth.frame, "terms"))
smoothers <- a$specials
```

オブジェクトの属性を取り出すにあたり、 `attr` は属性名を指定する必要がありますが、 `attributes` では全ての属性をリスト形式で取り出します。 `a` というオブジェクトには、具体的には以下のようなリストが格納されます。

```{r}
> a
$variables
list(wage, s(year, 4), s(age, 5), education)

$factors
           s(year, 4) s(age, 5) education
wage                0         0         0
s(year, 4)          1         0         0
s(age, 5)           0         1         0
education           0         0         1

$term.labels
[1] "s(year, 4)" "s(age, 5)"  "education" 

$specials
$specials$s
[1] 2 3

$specials$lo
NULL

$specials$random
NULL


$order
[1] 1 1 1

$intercept
[1] 1

$response
[1] 1

$class
[1] "terms"   "formula"

$.Environment
<environment: R_GlobalEnv>

$predvars
list(wage, s(year, 4), s(age, 5), education)

$dataClasses
      wage s(year, 4)  s(age, 5)  education 
 "numeric"  "numeric"  "numeric"   "factor" 
```

`a$specials$s` には `2 3` という数字が入っていますが、これは `smooth.frame` の2・3列目が平滑化の対象であるということだと思います。

今回は平滑化が含まれるので以下が処理されます：

```{r}
if (length(smoothers) > 0) {
    ### NA ではない要素を取り出す
    smoothers <- smoothers[sapply(smoothers, length) > 0]
    
    ### 以下の処理はちょっとよくわからない
    for (i in seq(along = smoothers)) {
        tt <- smoothers[[i]]
        ff <- apply(a$factors[tt, , drop = FALSE], 2, any)
        smoothers[[i]] <- if (any(ff)) 
            seq(along = ff)[a$order == 1 & ff]
        else NULL
    }
}

```
`smoothers` に格納されている数値が `1 2` になりました。

次に、以下の処理ではパラメータの推定に使われるエンジンを決めます。平滑化が含まれるケースでは `general.wam` または `{s, lo}.wam` が、そうでなければ `lm.wfit` が選ばれます。二種類以上の平滑化関数（`s` , `lo`, `random`）が指定されている、または `s` `lo` 以外の平滑化関数が指定されている場合には `general.wam` が選ばれるようです。

```{r}
### smoother が指定されている場合、ここが処理される
if (length(smoothers) > 0) {
    gam.wlist = gam.smoothers()$wlist
    smooth.labels <- a$term.labels[unlist(smoothers)]
    assignx <- attr(x, "assign")
    assignx <- assign.list(assignx, a$term.labels)
    which <- assignx[smooth.labels]

    ### ２つ以上の smoothers が指定されている場合は general.wam が指定される
    ### wam は weighted additive model
    if (length(smoothers) > 1) 
        bf <- "general.wam"

    ### 今回のケース（平滑化の関数として s を指定）はこちらで、 s.wam が指定される。
    else {
        sbf <- match(names(smoothers), gam.wlist, FALSE)
        bf <- if (sbf) 
            paste(gam.wlist[sbf], "wam", sep = ".")
        else "general.wam"
    }

    ### bf にオプション部分を文字列で結合
    bf.call <- parse(text = paste(bf, "(x, z, wz, fit$smooth, which, fit$smooth.frame,bf.maxit,bf.epsilon, trace)", 
        sep = ""))[[1]]
    s <- matrix(0, length(y), length(which))
    dimnames(s) <- list(names(y), names(which))
    fit <- list(smooth = s, smooth.frame = smooth.frame)
}
### 平滑化しない場合。 通常の lm.wfit に渡す。なお general.wam でも lm.wfit が使われる。
### ここの深掘りは以前のGLMの記事を紹介
else {
    bf.call <- expression(lm.wfit(x, z, wz, method = "qr", 
        singular.ok = TRUE))
    bf <- "lm.wfit"
}
```

上記のコードブロックの最後に `lm.wfit` が使われていますが、LMやGLMの中身がどうなっているのかについては過去記事を参照してください。

GLMの過去記事


```{r}
    ### ここから反復に入る
    old.dev <- 10 * new.dev + 10
    for (iter in 1:maxit) {

        ### weight が 0 のデータは除外する
        good <- weights > 0
        varmu <- variance(mu)
        if (any(is.na(varmu[good]))) 
            stop("NAs in V(mu)")
        if (any(varmu[good] == 0)) 
            stop("0s in V(mu)")
        mu.eta.val <- mu.eta(eta)
        if (any(is.na(mu.eta.val[good]))) 
            stop("NAs in d(mu)/d(eta)")
        good <- (weights > 0) & (mu.eta.val != 0)

        ### z を生成。ただし bf.call で二番目の引数は y なので、この z は目的変数の意味
        z <- eta - offset
        z[good] <- z[good] + (y - mu)[good]/mu.eta.val[good]

        ### wz を生成。重み。今回のケースでは無視して良い
        wz <- weights
        wz[!good] <- 0
        wz[good] <- wz[good] * mu.eta.val[good]^2/varmu[good]

        ### ここで bf.call が評価される。 s.wam の場合、bakfit が呼ばれる。
        ### bf.call で指定されている smooth.frame はこの時点では単なる data.frame 
        fit <- eval(bf.call)

        ### 予測値にオフセットを加算する
        eta <- fit$fitted.values + offset

        ### eta から mu に変換する
        mu <- linkinv(eta)

        ### デビアンスを更新
        old.dev <- new.dev
        new.dev <- sum(dev.resids(y, mu, weights))

        ### ここの trace は対角和ではなく、 gam のオプションでループごとのデビアンスをモニターできる
        if (trace) 
            cat("GAM ", bf, " loop ", iter, ": deviance = ", 
                format(round(new.dev, digits)), " \n", sep = "")

        ### ループの打ち切り判定
        ### デビアンスが NA となった場合、警告を出して打ち切る
        if (is.na(new.dev)) {
            one.more <- FALSE
            warning("iterations terminated prematurely because of singularities")
        }
        ### 差が十分に小さければ終了
        else one.more <- abs(old.dev - new.dev)/(old.dev + 0.1) > 
            epsilon
        if (!one.more) 
            break
    }

    fitqr <- fit$qr
    xxnames <- xnames[fitqr$pivot]
    nr <- min(sum(good), nvars)
    if (nr < nvars) {
        Rmat <- diag(nvars)
        Rmat[1:nr, 1:nvars] <- fitqr$qr[1:nr, 1:nvars]
    }
    else Rmat <- fitqr$qr[1:nvars, 1:nvars]
    Rmat <- as.matrix(Rmat)
    Rmat[row(Rmat) > col(Rmat)] <- 0
    dimnames(Rmat) <- list(xxnames, xxnames)
    names(fit$residuals) <- ynames
    names(mu) <- ynames
    names(eta) <- ynames

    ### eta and mu
    fit$additive.predictors <- eta
    fit$fitted.values <- mu
    names(fit$weights) <- ynames
    names(fit$effects) <- c(xxnames[seq(len = fitqr$rank)], rep.int("", 
        sum(good) - fitqr$rank))
    if (length(fit$smooth) > 0) 
        fit$smooth.frame <- smooth.frame[smooth.labels]
    wtdmu <- if (a$intercept) 
        sum(weights * y)/sum(weights)
    else linkinv(offset)
    nulldev <- sum(dev.resids(y, wtdmu, weights))
    n.ok <- nobs - sum(weights == 0)
    nulldf <- n.ok - as.integer(a$intercept)
    rank <- n.ok - fit$df.residual
    aic.model <- aic(y, nobs, mu, weights, new.dev) + 2 * rank
    if (!is.null(fit$smooth)) {
        nonzeroWt <- (wz > 0)
        nl.chisq <- gam.nlchisq(fit$qr, fit$residuals, wz, fit$smooth)
    }
    else nl.chisq <- NULL
    fit <- c(fit, list(R = Rmat, rank = fitqr$rank, family = family, 
        deviance = new.dev, aic = aic.model, null.deviance = nulldev, 
        iter = iter, prior.weights = weights, y = y, df.null = nulldf, 
        nl.chisq = nl.chisq))
    fit
}
```

#### 




#### gam()の残り

```{r}
    ### offset が指定されており intercept 項がある場合
    if (length(offset) && attr(mt, "intercept") > 0) {
        fit$null.dev <- glm.fit(x = X[, "(Intercept)", drop = FALSE], 
            y = Y, weights = weights, offset = offset, family = family, 
            control = control[c("epsilon", "maxit", "trace")], 
            intercept = TRUE)$deviance
    }
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    if (x) 
        fit$x <- X
    if (!y) 
        fit$y <- NULL
    fit <- c(fit, list(call = call, formula = formula, terms = mt, 
        data = data, offset = offset, control = control, method = method, 
        contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
            mf)))
    class(fit) <- c("Gam", "glm", "lm")
    if (!is.null(fit$df.residual) && !(fit$df.residual > 0)) 
        warning("Residual degrees of freedom are negative or zero.  This occurs when the sum of the parametric and nonparametric degrees of freedom exceeds the number of observations.  The model is probably too complex for the amount of data available.")
    fit
}
```









```{r}
# fit <- lm(wage ~ poly(age, 4), data = Wage)
# coef(summary(fit))
# tmp <- head(cbind(Wage$age, poly(Wage$age, 4)))
# tmp
# fit2 <- lm(wage ~ poly(age, 4, raw = T), data = Wage)
# coef(summary(fit2))
# tmp2 <- head(cbind(Wage$age, poly(Wage$age, 4, raw = T)))
# tmp2
# tmp2[, 2]^2
# tmp2[, 2]^3
# tmp2[, 2]^4
```













```{r}
agelims <- range(Wage$age)
age.grid <- seq(from = agelims[1], to = agelims[2])
preds <- predict(fit, newdata = list(age = age.grid), se = TRUE)
se.bands <- cbind(preds$fit + 2 * preds$se.fit, preds$fit - 2 * preds$se.fit)
par(mfrow = c(1, 1), mar = c(4.5, 4.5, 1, 1), oma = c(0, 0, 4, 0))
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Quad Polynomial", outer = T)
lines(age.grid, preds$fit, lwd = 2, col = "blue")
matlines(age.grid, se.bands, lwd = 1, col = "blue", lty = 3)
```




```{r}
library(splines)
```



```{r}
plot(Wage$age, ns(Wage$age))
```


```{r}
par(mfrow = c(2, 2), cex = .5)
plot(ns(Wage$age, df = 4)[, 1], Wage$wage)
plot(ns(Wage$age, df = 4)[, 2], Wage$wage)
plot(ns(Wage$age, df = 4)[, 3], Wage$wage)
plot(ns(Wage$age, df = 4)[, 4], Wage$wage)
```



```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Smooth spline")
fit <- smooth.spline(Wage$age, Wage$wage, df = 16)
fit2 <- smooth.spline(Wage$age, Wage$wage, cv = TRUE)
fit2$df
lines(fit, col = "red", lwd = 2)
lines(fit2, col = "blue", lwd = 2)
legend("topright", legend = c("16 DF", "6.8 DF"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```

```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Loess")
fit = loess(wage ~ age, span = .2, data = Wage)
fit2 = loess(wage ~ age, span = .5, data = Wage)
lines(age.grid, predict(fit, data.frame(age = age.grid)),
      col = "red", lwd = 2)
lines(age.grid, predict(fit2, data.frame(age = age.grid)),
      col = "blue", lwd = 2)
legend("topright", legend = c("Span = 0.2", "Span = 0.5"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```



```{r}
gam1 <- lm(wage ~ ns(year, 4) + ns(age, 5) + education, data = Wage)
coef(summary(gam1))
```

```{r}
plot(gam1)
```

```{r}
library(gam)
```

```{r}
gam.m3 <- gam(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.m3, se = TRUE, col = "blue")
```

`gam1` は `lm` で当てはめているが `plot.Gam` が利用できる

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam1, se = TRUE, col = "red")
```


平滑化スプラインを使う場合は `lm` ではなく `gam` を使わないとまともに計算できない

```{r}
gam.m4 <- lm(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```
```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.m4, se = TRUE, col = "red")
```


```{r}
gam.lo <- gam(wage ~ s(year, 4) + lo(age, span = 0.7) + education,
              data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.lo, se = TRUE, col = "blue")
```


```{r}
gam.lo.i <- gam(wage ~ lo(year, age, span = 0.5) + education,
                data = Wage)
```

```{r}
# install.packages("akima")
library(akima)
```

```{r}
plot(gam.lo.i)
```


```{r}
gam.lr <- gam(I(wage > 250) ~ year + s(age, 5) + education,
              family = "binomial", data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.lr, se = TRUE, col = "blue")
```

```{r}
gam.lr.s <- gam(I(wage > 250) ~ year + s(age, 5) + education,
                family = "binomial", data = Wage, 
                subset = (education != "1. < HS Grad"))
par(mfrow = c(1, 3))
plot(gam.lr.s, se = TRUE, col = "blue")
```


モデルオブジェクトが `smooth` を持つか
```{r}
is.null(gam.m4$smooth)
```

```{r}
is.null(gam.m3$smooth)
```


新規データに対してはSEは出せない

```{r}
nd <- head(Wage, 5)
predict(gam.m3, nd, se.fit = TRUE)
```



まずは `predict.glm` で予測値を求める。当然答えは異なる。

```{r}
predict.glm(gam.m3, nd)
predict.Gam(gam.m3, nd)
```


使用している変数で model.frame を作成する

```{r}
Terms <- delete.response(gam.m3$terms)
model.frame(Terms, nd)
```


```{r}
!is.null(cl <- attr(Terms, "dataClasses"))
```

```{r}
smooth.frame <- model.frame(Terms, nd, na.action = na.fail, 
                            xlev = gam.m3$xlevels)
.checkMFClasses(cl, smooth.frame)
```


モデルオブジェクトから平滑化された説明変数の列名を取ってくる。
上で作った `smooth.frame` ではなく、モデルオブジェクトに格納された
`smooth.frame` なので注意。

```{r}
nrows <- nrow(nd)
smooth.labels <- names(gam.m3$smooth.frame)
n.smooths <- length(smooth.labels)
pred.s <- array(0, c(nrows, n.smooths), list(row.names(smooth.frame), 
            smooth.labels))
pred.s
```



```{r}
terms <- labels(gam.m3)
smooth.labels[match(smooth.labels, terms, 0) > 0]
```

モデルオブジェクトの `smooth.frame` において該当する列の "call" アトリビューションを取り出す
```{r}
TT <- "s(year, 4)"
Call <- attr(gam.m3$smooth.frame[[TT]], "call")
Call
```

上記にオプションを追加する。 `Call` は `call` クラスであり、
List における各要素にオプションを持つ感じ。

```{r}
Call$xeval <- substitute(smooth.frame[[TT]], list(TT = TT))
Call
```


データの各点の重み w と、上で作った z を渡して `gam.s` を呼ぶ。
`data` オブジェクトの代わりにモデルオブジェクトの `smooth.frame` を渡す。
`spar` はスムージングパラメータ、 `df` は平滑化の自由度。 `df` が指定されている場合はこちらが使われる

```{r}
w <- gam.m3$weights
z <- gam.m3$residuals + gam.m3$smooth[, TT]
# pred.s[, TT] <- eval(Call)
pred.s <- gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```


`df` を指定した状態で `spar` を変えても予測値は変わらないはず。

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 4, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 4, xeval = smooth.frame[[TT]])
```

`df` を0にすると `spar` が使われる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 0, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 0, xeval = smooth.frame[[TT]])
```

`df` を1以上で変化させると予測値が変わる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 2, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```


