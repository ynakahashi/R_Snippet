---
title: "Double Poisson"
author: "ynakahashi"
date: "2019/2/14"
output: html_document
---

## 過小分散なカウントデータを扱いたい

### 背景
カウントデータをモデリングしようと思ったとき、まず思い浮かべる分布といえばポアソン分布だと思います。しかしポアソン分布は期待値と分散が等しいという性質があるため、実際のデータに当てはめようとすると、（ポアソン分布から期待されるものよりも）分散が大きい（**過分散**）または小さい（**過小分散**）という問題に直面することがあります。

そのようなときに、過分散ならともかく[^1]、過小分散の場合にどんな分布を当てはめれば良いのか知らなかったのですが、先日某所で `Double Poisson`分布というものを教えてもらったので試してみます。

[^1]:基本的には負の二項分布を当てはめますが、過分散の原因が個体差に由来すると考えられるならば混合モデルにするかもしれません

### `doublepoisson`を触ってみる
いきなりですが、Double Poissonで調べてみたところ、Rでは`rmutil`パッケージで`doublepoisson`関数が使えるようです。早速インストールしてみます。

```{r}
install.packages("rmutil")
library(rmutil)
```

`rmutil`では、`runif`や`dnorm`などと同じようにr/d/p/qを頭に付けた`doublepois`関数が使えます。Double Poisson分布に従う乱数を生成してみましょう。Overdispersion parameterとして`s`が指定できるので、平均よりも小さめの値にしてみます。

```{r}
set.seed(123)
n <- 500
m <- 5 # 平均
s <- 2 # Overdispersion parameter
d <- data.frame(y = rdoublepois(n, m, s))
```

```{r}
head(d)
```


ぱっと見た感じでは通常のポアソンと変わりありません。

`rpois`と比べ分散が小さいデータを生成できているか確認してみましょう。カウントごとの頻度を描き[^2]、その上に（通常の）ポアソン分布の確率関数を引いてみます。

[^2]:`hist()`で作図したプロットに上手く確率密度関数の曲線を載せられなかったので棒グラフにした

```{r}
## プロット用に最大値を得る
max_count <- max(d$y)
## 平均がmのポアソン分布における確率密度を得る
nrm_poi <- dpois(1:max_count, m)
## データの分布を得る
dens <- table(d$y) / nrow(d)
## プロット用に最大密度を得る。まるめの単位はよしなに
dens_vec <- rep(0, length(1:max_count))
dens_vec[as.integer(names(dens))] <- dens
max_dens <- ceiling(max(c(dens, nrm_poi)) * 20) / 20


## ヒストグラムではなく棒グラフで作図するので、座標をしていする
xleft <- 1:max_count - 0.2
xright <- 1:max_count + 0.2
ybottom <- rep(0, length(1:max_count))
ytop <- dens_vec

## 棒グラフに確率密度関数を載せる
plot(1:max_count, xlim = c(1, max_count), ylim = c(0, max_dens), type = "n", 
     xlab = "", ylab = "")
rect(xleft = xleft, ybottom = ybottom, xright = xright, ytop = ytop, col = "gray")
lines(nrm_poi, col = "blue")


# max_count <- max(d$y)
# nrm_poi <- dpois(1:max_count, m)
# dens <- table(d$y) / nrow(d)
# max_dens <- ceiling(max(c(dens, nrm_poi)) * 20) / 20
# 
# 
# barplot(dens, xlab = "", col = "gray", main = "", ylim = c(0, max_dens))
# par(new = T)
# plot(1:max_count, nrm_poi, xlim = c(1.2, max_count+0.2), 
#      axes = F, type = "l", xlab = "", ylab = "", ylim = c(0, max_dens))


# ## プロット用に最大値を取得する
# max_count <- max(d$y)
# ## Y軸用に一度ヒストグラムを描く
# plt <- hist(d$y, xlim = c(0, max_count), probability = T)
# ## Y軸の値(densitu)を取得し、キリの良い数値を見つける
# max_dens <- ceiling(max(plt$density) * 10) / 10
# 
# ## ヒストグラムのxの値に大して確率密度を求める。
# nrm_poi <- dpois(unique(as.integer(plt$breaks)), m)
# ## 改めてヒストグラムを描く
# hist(d$y, xlim = c(0, max_count), xlab = "", col = "gray", main = "", 
#      ylim = c(0, max_dens), probability = T)
# par(new = T)
# ## 通常のポアソン分布の確率密度を描く
# plot(unique(as.integer(plt$breaks)), nrm_poi, xlim = c(0.5, max_count+0.5), 
#      axes = F, type = "l", xlab = "", ylab = "", ylim = c(0, max_dens))
```

通常のポアソン分布で期待される密度（青線）と比較するとDouble Poisson分布では平均値周りの密度が高くなっており、全体としてバラツキが小さくなっているようです。では`s`の値を変えるとどうなるでしょうか？

簡単に変更できるように関数化しておきます。

```{r}
plot_double_poisson <- function(n, m, s) {
   
   d <- data.frame(y = rdoublepois(n, m, s))

   max_count <- max(d$y)
   nrm_poi <- dpois(0:max_count, m)
   dens <- table(d$y) / nrow(d)
   
   dens_vec <- rep(0, length(1:max_count))
   dens_vec[as.integer(names(dens))] <- dens
   max_dens <- ceiling(max(c(dens, nrm_poi)) * 20) / 20
   
   xleft <- 0:max_count - 0.2
   xright <- 0:max_count + 0.2
   ybottom <- rep(0, length(1:max_count))
   ytop <- dens_vec
   
   plot(0:max_count, xlim = c(0, max_count), ylim = c(0, max_dens), type = "n", 
        xlab = "", ylab = "")
   rect(xleft = xleft, ybottom = ybottom, xright = xright, ytop = ytop, col = "gray")
   lines(nrm_poi, col = "blue")

}
```

`s = 10`としてみましょう。

```{r}
plot_double_poisson(500, 5, 10)
```

逆に`s = 1`ではこうなります。

```{r}
plot_double_poisson(500, 5, 1)
```


おや？ `s`が小さい方がバラツキが大きくなっていますね。


### GLMを当てはめてみる

```{r}
res_glm <- glm(y ~ 1, d, family = poisson("log"))
summary(res_glm)
```


```{r}
exp(coef(res_glm))
mean(d$y)
```

Poissonなのでmu = varだが、実際の分散は

```{r}
var(d$y)
```


### `dglm`を当てはめてみる

```{r}
library(dglm)
res_dglm <- dglm::dglm(y ~ 1, ~1, data = d, family = poisson("log"))
```


```{r}
exp(res_dglm$coefficients[1])
```

今度は分散が小さすぎる？

```{r}
exp(res_dglm$dispersion.fit$coefficients)
var(d$y)
```



### 回帰係数を推定してみる

```{r}
set.seed(123)
n <- 1000
b <- 1.5
x <- runif(n, 3, 5)
m <- b * x
s <- 2
y1 <- rdoublepois(n, m, s)
y2 <- rpois(n, m)
d <- data.frame(y1, y2, x)
```


```{r}
mean(d$y1)
mean(d$y2)
var(d$y1)
var(d$y2)
```


```{r}
res_glm_1 <- glm(y1 ~ x, d, family = poisson("log"))
res_glm_2 <- glm(y2 ~ x, d, family = poisson("log"))
exp(coef(res_glm_1))
exp(coef(res_glm_2))
```

```{r}
res_dglm_1 <- dglm(y1 ~ x, ~1, data = d, family = poisson("log"))
res_dglm_2 <- dglm(y2 ~ x, ~1, data = d, family = poisson("log"))
exp(res_dglm_1$coefficients)
exp(res_dglm_2$coefficients)
exp(res_dglm_1$dispersion.fit$coefficients)
exp(res_dglm_2$dispersion.fit$coefficients)
```


### `optim`で推定してみる


```{r}
b <- c(0, 1, 3)
my_obj_fun <- function(b) {
   b1 <- b[1]
   b2 <- b[2]
   b3 <- b[3]
   ret <- sum(ddoublepois(d$y1, exp(b1 + d$x * b2), b3, log = TRUE))
   ret
}

res_opt_1 <- optim(b, my_obj_fun, control = list(fnscale=-1))
res_opt_2 <- optim(res_opt_1$par, my_obj_fun, control = list(fnscale=-1), method = "BFGS")
res_opt_1$par
res_opt_2$par
```


```{r}
exp(res_opt_2$par)[-3]
res_opt_2$par[3]
```

```{r}
exp(res_dglm_1$coefficients)
exp(res_dglm_1$dispersion.fit$coefficients)
var(d$y1)
```









