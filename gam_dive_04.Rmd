---
title: "GAMをもう少し理解したい④"
output: html_document
---
前回の続きです。過去記事はこちらから。


[:contents]

### GAMの実装
#### backfit
##### bakfit

さて `bakfit` ですが、このサブルーチンは***バックフィッティング***というアルゴリズムを定義しています。このアルゴリズムは、簡単に言えば「関心のある平滑化対象変数を順番に残差に対してフィッティングしていく」方法です。Wikipediaの[バックフィッティングのページ](https://en.wikipedia.org/wiki/Backfitting_algorithm)からアルゴリズムの部分について抜粋してきましょう：

ここで画像を入れる

ポイントは４行目の (a) のところで、

[tex:Smooth[{y_{i} - \hat{\alpha} - \sum_{k \neq j}\hat{f}(x_{ij})}_{1}^{N}]]

とあるように、目的変数から定数部（線形部分）および関心のある平滑化対象変数"**以外**"（非線形部分）を引いています。すなわち「平滑化対象変数で説明される部分」と「確率的な誤差」で構成される部分のみを残し、平滑化を行なっていることがわかります。これを非線形としたい変数全てについて収束するまで順次繰り返す、というのがバックフィッティングの流れです。

ちなみにこのバックフィッティング、Wikipediaの[ページ](https://en.wikipedia.org/wiki/Backfitting_algorithm)では以下のような説明があります：

> the backfitting algorithm is equivalent to the Gauss–Seidel method algorithm for solving a certain linear system of equations.

さらにGauss–Seidel法について調べると（[こちら](https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method)）、これはn元の連立一次方程式を反復的に解くための手法であることが解説されているのですが、その中で以下の記述があります：

> The Gauss–Seidel method now solves the left hand side of this expression for x, using previous value for x on the right hand side.

で、これは以下のように解くことができます：

[tex: {\displaystyle x_{i}^{(k+1)}={\frac {1}{a_{ii}}}\left(b_{i}-\sum _{j=1}^{i-1}a_{ij}x_{j}^{(k+1)}-\sum _{j=i+1}^{n}a_{ij}x_{j}^{(k)}\right),\quad i=1,2,\dots ,n.}]

ここで括弧の中に着目すると、$b$から$ax$が順次引かれている（二項目と三項目）のですが、総和記号のインデックスには$i$が含まれていません。つまり更新の対象である$i$番目の$x$**以外**を順番に引いており、バックフィッティングと同じような計算になっていることがわかります。なお括弧の中の三項目は添え字が `(k)` ですが、二項目では `(k+1)` になっており、更新後の$x$を直接使っていることがわかります。さらにちなみに、ここで逐次更新するのではなく一度全ての解を求めてから一斉に更新する方法をヤコビ法といいます。

では上記のアルゴリズムが `bakfit` ではどのように実装されているのかを確認してみましょう。と言いつつ実は `bakfit` 自体は基本的に以下のように `backf1` を呼び出しているだけです。

```{fortran}
subroutine bakfit(x,npetc,y,w,which,spar,dof,match,nef,
			etal,s,eta,beta,var,tol,
			qr,qraux,qpivot,effect,work)
implicit double precision(a-h,o-z)
logical ifvar
integer npetc(7),iter
integer n,p,q,which(*),match(*),nef(*),nit,maxit,qrank,qpivot(*)
double precision x(*),y(*),w(*),spar(*),dof(*),
			etal(*),s(*),eta(*),beta(*),var(*),tol,
			qr(*),qraux(*),effect(*),work(*)
n=npetc(1)
p=npetc(2)
q=npetc(3)
ifvar=.false.
if(npetc(4)==1)ifvar=.true.
maxit=npetc(6)
qrank=npetc(7)
do i=1,q{work(i)=dof(i)}
call backf1(x,n,p,y,w,q,which,spar,dof,match,nef,
            etal,s,eta,beta,var,ifvar,tol,nit,maxit,
            qr,qraux,qrank,qpivot,effect,work(q+1),work(q+n+1),
            work(q+2*n+1),work(q+3*n+1),work(q+4*n+1))

npetc(7)=qrank
return
end
```

なので `backf1` を確認することにしましょう。

##### backf1
前回同様まずは `backf1` の処理全体をさっと眺めて見通しを良くします。 `backf1` ではざっくりと

1. 前処理
2. バックフィッティング
3. `eta` を再定義

という処理が行われます。

```{fortran}
subroutine backf1(x,n,p,y,w,q,which,spar,dof,match,nef,
			etal,s,eta,beta,var,ifvar,tol,nit,maxit,
			qr,qraux,qrank,qpivot,effect,z,old,sqwt,sqwti,work)
implicit double precision(a-h,o-z)
logical ifvar
integer n,p,q,which(q),match(n,q),nef(q),nit,maxit,qrank,qpivot(p)
double precision x(n,p),y(n),w(n),spar(q),dof(q),
			etal(n),s(n,q),eta(n),beta(p),var(n,q),tol,
			qr(n,p),qraux(p),effect(n),work(*)
double precision z(*),old(*),dwrss,ratio
double precision sqwt(n),sqwti(n)
logical anyzwt
double precision deltaf, normf,onedm7
integer job,info

onedm7=1d-7
job=1101;info=1
if(q==0)maxit=1
ratio=1d0

## 1. 前処理
### データに重みをつける
anyzwt=.false.
do i=1,n{
	if(w(i)>0d0){
		sqwt(i)=dsqrt(w(i))
		sqwti(i)=1d0/sqwt(i)
	}
	else{
		sqwt(i)=0d0
		sqwti(i)=0d0
		anyzwt=.true.
		}
	}

### QR分解する
if(qrank==0){
	do i=1,n{
		do j=1,p{
			qr(i,j)=x(i,j)*sqwt(i)
			}
		}
	do j=1,p{qpivot(j)=j}
	call dqrdca(qr,n,n,p,qraux,qpivot,work,qrank,onedm7)
	}

### eta に 非線形項 s(i,j) を加算する
do i=1,n{
	eta(i)=0d0
	for(j=1;j<=q;j=j+1){
		eta(i)=eta(i)+s(i,j)
		}
	}


## 2. バックフィッティング
nit=0
while ((ratio > tol )&(nit < maxit)){
	deltaf=0d0
	nit=nit+1

	### まずは Linear part + error 部分に最小二乗法を当てはめる
	do i=1,n{
		z(i)=(y(i)-eta(i))*sqwt(i) 
		old(i)=etal(i)
	}
	call dqrsl(qr,n,n,qrank,qraux,z,work(1),effect(1),beta,
		work(1),etal,job,info)

	### 重みの逆数で戻し、 etal を更新
	do i=1,n{
		etal(i)=etal(i)*sqwti(i)
		}

	### 次に平滑化対象の変数についてループ
	for(k=1;k<=q;k=k+1){
		j=which(k)
		do i=1,n{
			old(i)=s(i,k)
			z(i)=y(i)-etal(i)-eta(i)+old(i)
		}
    if(nit>1){dof(k)=0d0}
		
		### splsmで平滑化
		call splsm(x(1,j),z,w,n,match(1,k),nef(k),spar(k),
			dof(k),s(1,k),s0,var(1,k),ifvar,work)
		do i=1,n{ 
			eta(i)=eta(i)+s(i,k)-old(i)
			etal(i)=etal(i)+s0
		}
		
		deltaf=deltaf+dwrss(n,old,s(1,k),w)
		}
	
	### whileループの打ち切り判定
	normf=0d0
	do i=1,n{
		normf=normf+w(i)*eta(i)*eta(i)
		}
	if(normf>0d0){
		ratio=dsqrt(deltaf/normf)
		}
	 else {ratio = 0d0}
	}

### 3. eta を再定義
do j=1,p {work(j)=beta(j)}
do j=1,p {beta(qpivot(j))=work(j)}
if(anyzwt){
	do i=1,n {
		if(w(i) <= 0d0){
			etal(i)=0d0
			do j=1,p{
				etal(i)=etal(i)+beta(j)*x(i,j)
				}
			}
		}
	}

do i=1,n
	eta(i)=eta(i)+etal(i)
	
do j=1,q {
	call unpck(n,nef(j),match(1,j),var(1,j),old)
	do i=1,n {var(i,j)=old(i)}
	}

return
end
```

３つ目の工程で `eta` の再定義とあるのですが、これまでの処理では `eta` は「 `y` をリンク関数で変換したもの」として扱われてきたものの、 `backf1` の中では 「平滑化対象変数によって構成される部分」として扱われており、混乱しやすいので注意が必要です。つまり `backf1` の中では `y` を「線形部分」と「非線形（平滑化）部分」に分割し、前者を `etal` 、後者を `eta` として計算が行われます。

では一つずつ見ていきましょう。

###### 1. 前処理
まずは前処理です。ここでは

- データに重みをつける
- QR分解する
- `eta` （非線形部分）を定義する

という工程が行われます。

```{fortran}
### weight の平方根をとって逆数にする
anyzwt=.false.
do i=1,n{
	if(w(i)>0d0){
		sqwt(i)=dsqrt(w(i)) ## Fortranの組み込み関数。sqrt()
		sqwti(i)=1d0/sqwt(i) ## weight の逆数
	}
	else{
		sqwt(i)=0d0
		sqwti(i)=0d0
		anyzwt=.true.
		}
	}

### qrank が 0 のときは、x に重みを加えた上で QR 分解する
if(qrank==0){
	do i=1,n{
		do j=1,p{
			### 重みを乗じた x を生成
			qr(i,j)=x(i,j)*sqwt(i) # qr は n*p の行列
			}
		}
	do j=1,p{qpivot(j)=j} ### qvivot は長さ p の integer。1~p の数字を格納

	### QR分解
	### https://github.com/cran/gam/blob/master/inst/ratfor/linear.r
	call dqrdca(qr,n,n,p,qraux,qpivot,work,qrank,onedm7)
	}

### eta に 非線形項 s(i,j) を加算する
### ただしここで eta は fitted value ではなく 0 スタート
### s は線形部分とは独立な平滑化部分で、バックフィッティングで更新する
do i=1,n{
	eta(i)=0d0 # 0.0 にリセット 
	for(j=1;j<=q;j=j+1){ # 平滑化対象の変数について
		eta(i)=eta(i)+s(i,j) # 平滑化部分を順次加算していく
		}
	}
```



###### 2. バックフィッティング


###### 3. `eta` の再定義


----- 以下は必要になったら -----



```{r}
### gam.fit に戻ってきた
fitqr <- fit$qr
xxnames <- xnames[fitqr$pivot]
nr <- min(sum(good), nvars)
if (nr < nvars) {
    Rmat <- diag(nvars)
    Rmat[1:nr, 1:nvars] <- fitqr$qr[1:nr, 1:nvars]
}
else Rmat <- fitqr$qr[1:nvars, 1:nvars]
Rmat <- as.matrix(Rmat)
Rmat[row(Rmat) > col(Rmat)] <- 0
dimnames(Rmat) <- list(xxnames, xxnames)
names(fit$residuals) <- ynames
names(mu) <- ynames
names(eta) <- ynames

### eta and mu
fit$additive.predictors <- eta
fit$fitted.values <- mu
names(fit$weights) <- ynames
names(fit$effects) <- c(xxnames[seq(len = fitqr$rank)], rep.int("", 
    sum(good) - fitqr$rank))
if (length(fit$smooth) > 0) 
    fit$smooth.frame <- smooth.frame[smooth.labels]
wtdmu <- if (a$intercept) 
    sum(weights * y)/sum(weights)
else linkinv(offset)
nulldev <- sum(dev.resids(y, wtdmu, weights))
n.ok <- nobs - sum(weights == 0)
nulldf <- n.ok - as.integer(a$intercept)
rank <- n.ok - fit$df.residual
aic.model <- aic(y, nobs, mu, weights, new.dev) + 2 * rank
if (!is.null(fit$smooth)) {
    nonzeroWt <- (wz > 0)
    nl.chisq <- gam.nlchisq(fit$qr, fit$residuals, wz, fit$smooth)
}
else nl.chisq <- NULL
fit <- c(fit, list(R = Rmat, rank = fitqr$rank, family = family, 
    deviance = new.dev, aic = aic.model, null.deviance = nulldev, 
    iter = iter, prior.weights = weights, y = y, df.null = nulldf, 
    nl.chisq = nl.chisq))
fit
}
```

#### 




#### gam()の残り

```{r}
    ### offset が指定されており intercept 項がある場合
    if (length(offset) && attr(mt, "intercept") > 0) {
        fit$null.dev <- glm.fit(x = X[, "(Intercept)", drop = FALSE], 
            y = Y, weights = weights, offset = offset, family = family, 
            control = control[c("epsilon", "maxit", "trace")], 
            intercept = TRUE)$deviance
    }
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    if (x) 
        fit$x <- X
    if (!y) 
        fit$y <- NULL
    fit <- c(fit, list(call = call, formula = formula, terms = mt, 
        data = data, offset = offset, control = control, method = method, 
        contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
            mf)))
    class(fit) <- c("Gam", "glm", "lm")
    if (!is.null(fit$df.residual) && !(fit$df.residual > 0)) 
        warning("Residual degrees of freedom are negative or zero.  This occurs when the sum of the parametric and nonparametric degrees of freedom exceeds the number of observations.  The model is probably too complex for the amount of data available.")
    fit
}
```









```{r}
# fit <- lm(wage ~ poly(age, 4), data = Wage)
# coef(summary(fit))
# tmp <- head(cbind(Wage$age, poly(Wage$age, 4)))
# tmp
# fit2 <- lm(wage ~ poly(age, 4, raw = T), data = Wage)
# coef(summary(fit2))
# tmp2 <- head(cbind(Wage$age, poly(Wage$age, 4, raw = T)))
# tmp2
# tmp2[, 2]^2
# tmp2[, 2]^3
# tmp2[, 2]^4
```













```{r}
agelims <- range(Wage$age)
age.grid <- seq(from = agelims[1], to = agelims[2])
preds <- predict(fit, newdata = list(age = age.grid), se = TRUE)
se.bands <- cbind(preds$fit + 2 * preds$se.fit, preds$fit - 2 * preds$se.fit)
par(mfrow = c(1, 1), mar = c(4.5, 4.5, 1, 1), oma = c(0, 0, 4, 0))
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Quad Polynomial", outer = T)
lines(age.grid, preds$fit, lwd = 2, col = "blue")
matlines(age.grid, se.bands, lwd = 1, col = "blue", lty = 3)
```




```{r}
library(splines)
```



```{r}
plot(Wage$age, ns(Wage$age))
```


```{r}
par(mfrow = c(2, 2), cex = .5)
plot(ns(Wage$age, df = 4)[, 1], Wage$wage)
plot(ns(Wage$age, df = 4)[, 2], Wage$wage)
plot(ns(Wage$age, df = 4)[, 3], Wage$wage)
plot(ns(Wage$age, df = 4)[, 4], Wage$wage)
```



```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Smooth spline")
fit <- smooth.spline(Wage$age, Wage$wage, df = 16)
fit2 <- smooth.spline(Wage$age, Wage$wage, cv = TRUE)
fit2$df
lines(fit, col = "red", lwd = 2)
lines(fit2, col = "blue", lwd = 2)
legend("topright", legend = c("16 DF", "6.8 DF"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```

```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Loess")
fit = loess(wage ~ age, span = .2, data = Wage)
fit2 = loess(wage ~ age, span = .5, data = Wage)
lines(age.grid, predict(fit, data.frame(age = age.grid)),
      col = "red", lwd = 2)
lines(age.grid, predict(fit2, data.frame(age = age.grid)),
      col = "blue", lwd = 2)
legend("topright", legend = c("Span = 0.2", "Span = 0.5"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```



```{r}
gam1 <- lm(wage ~ ns(year, 4) + ns(age, 5) + education, data = Wage)
coef(summary(gam1))
```

```{r}
plot(gam1)
```

```{r}
library(gam)
```

```{r}
gam.m3 <- gam(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.m3, se = TRUE, col = "blue")
```

`gam1` は `lm` で当てはめているが `plot.Gam` が利用できる

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam1, se = TRUE, col = "red")
```


平滑化スプラインを使う場合は `lm` ではなく `gam` を使わないとまともに計算できない

```{r}
gam.m4 <- lm(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```
```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.m4, se = TRUE, col = "red")
```


```{r}
gam.lo <- gam(wage ~ s(year, 4) + lo(age, span = 0.7) + education,
              data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.lo, se = TRUE, col = "blue")
```


```{r}
gam.lo.i <- gam(wage ~ lo(year, age, span = 0.5) + education,
                data = Wage)
```

```{r}
# install.packages("akima")
library(akima)
```

```{r}
plot(gam.lo.i)
```


```{r}
gam.lr <- gam(I(wage > 250) ~ year + s(age, 5) + education,
              family = "binomial", data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.lr, se = TRUE, col = "blue")
```

```{r}
gam.lr.s <- gam(I(wage > 250) ~ year + s(age, 5) + education,
                family = "binomial", data = Wage, 
                subset = (education != "1. < HS Grad"))
par(mfrow = c(1, 3))
plot(gam.lr.s, se = TRUE, col = "blue")
```


モデルオブジェクトが `smooth` を持つか
```{r}
is.null(gam.m4$smooth)
```

```{r}
is.null(gam.m3$smooth)
```


新規データに対してはSEは出せない

```{r}
nd <- head(Wage, 5)
predict(gam.m3, nd, se.fit = TRUE)
```



まずは `predict.glm` で予測値を求める。当然答えは異なる。

```{r}
predict.glm(gam.m3, nd)
predict.Gam(gam.m3, nd)
```


使用している変数で model.frame を作成する

```{r}
Terms <- delete.response(gam.m3$terms)
model.frame(Terms, nd)
```


```{r}
!is.null(cl <- attr(Terms, "dataClasses"))
```

```{r}
smooth.frame <- model.frame(Terms, nd, na.action = na.fail, 
                            xlev = gam.m3$xlevels)
.checkMFClasses(cl, smooth.frame)
```


モデルオブジェクトから平滑化された説明変数の列名を取ってくる。
上で作った `smooth.frame` ではなく、モデルオブジェクトに格納された
`smooth.frame` なので注意。

```{r}
nrows <- nrow(nd)
smooth.labels <- names(gam.m3$smooth.frame)
n.smooths <- length(smooth.labels)
pred.s <- array(0, c(nrows, n.smooths), list(row.names(smooth.frame), 
            smooth.labels))
pred.s
```



```{r}
terms <- labels(gam.m3)
smooth.labels[match(smooth.labels, terms, 0) > 0]
```

モデルオブジェクトの `smooth.frame` において該当する列の "call" アトリビューションを取り出す
```{r}
TT <- "s(year, 4)"
Call <- attr(gam.m3$smooth.frame[[TT]], "call")
Call
```

上記にオプションを追加する。 `Call` は `call` クラスであり、
List における各要素にオプションを持つ感じ。

```{r}
Call$xeval <- substitute(smooth.frame[[TT]], list(TT = TT))
Call
```


データの各点の重み w と、上で作った z を渡して `gam.s` を呼ぶ。
`data` オブジェクトの代わりにモデルオブジェクトの `smooth.frame` を渡す。
`spar` はスムージングパラメータ、 `df` は平滑化の自由度。 `df` が指定されている場合はこちらが使われる

```{r}
w <- gam.m3$weights
z <- gam.m3$residuals + gam.m3$smooth[, TT]
# pred.s[, TT] <- eval(Call)
pred.s <- gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```


`df` を指定した状態で `spar` を変えても予測値は変わらないはず。

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 4, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 4, xeval = smooth.frame[[TT]])
```

`df` を0にすると `spar` が使われる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 0, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 0, xeval = smooth.frame[[TT]])
```

`df` を1以上で変化させると予測値が変わる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 2, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```
