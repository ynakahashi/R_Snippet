---
title: "GAMをもう少し理解したい④"
output: html_document
---

### GAMの実装
#### backfit.r
##### bakfit

```{fortran}
#### bakfit
subroutine bakfit(x,npetc,y,w,which,spar,dof,match,nef,
			etal,s,eta,beta,var,tol,
			qr,qraux,qpivot,effect,work)
#integer npetc(7)
#1:n
#2:p
#3:q
#4:ifvar
#5:nit
#6:maxit
#7:qrank
#subroutine bakfit(x,n,p,y,w,q,which,spar,dof,match,nef,
#			etal,s,eta,beta,var,ifvar,tol,nit,maxit,
#			qr,qraux,qrank,qpivot,work)
#This subroutine fits an additive spline fit to y
#All arguments are either double precision or integer


# bakfit uses the modified backfitting algorithm described in Buja, Hastie 
# and Tibshirani, Annals of Statistics, 1989. It calls splsm, and some
# linpack based routines


# This was written by Trevor Hastie in 1990
# It has been modified from the S3 version by Trevor Hastie
# in March 2005, to accommodate the modified sbart routine in R
# Note that spar has changed, and we change it here to conform with
# the smooth.spline routine in R


#INPUT
#
#x	double dim  n by p ; x variables, includes constant
#n	integer number of rows in x
#p	integer number of columns of x
#y	double length n	; y variable for smoothing
#w	double length n ; prior weights for smoothing, > 0
#q	integer number of nonlinear terms
#which 	integer length q indices of columns of x for nonlinear fits
#spar	double length q spars for smoothing; see below
#dof	double length q dof for/from smoothing; see below
#match 	integer n by q  matrix of match'es; see below
#nef	integer q vector of nef's; see below
#s	double n by q nonlinear part of the smooth functions
#		used as starting values. the linear part is
#		irrelevant
#ifvar	logical should the variance information be computed
#tol	double tolerance for backfitting convergence; 0.0005 is good
#maxit	integer maximum number of iterations; 15 is good
#qr	double n by p weighted qr decomposition of x
#qraux 	double p belongs with qr
#qrank	integer rank of x ; if qrank=0, then bakfit computes qr and qraux
#qpivot	integer p the columns of qr are rearranged according to pivot
#effec  double n effect vector
#work	double 
#	Let nk=max(nef)+2, then 
# 	work should be (10+2*4)*nk+5*nef+5*n+15 +q double


#BELOW
#
#the following comments come from documentation for splsm
#	they apply to each element of spar,dof match etc
#spar	double smoothing parameter -1.5 <spar<1.5; default is 1
#dof	double  equivalent degrees of freedom
#		if dof is 0, spar is used
#               if 0< dof <1, dof = 1                         
#		if dof >=1, dof is used
#		note: dof does not use the constant term
#match 	integer length n -- in S language x[i] == sort(unique(x)[match[i]]
#		match is produced by subroutine namat
#nef	number of unique elements in x; so match has values between 1 and nef+1
#		missing data are given the match number nef+1
#work	double workspace of length (10+2*4)*(nef+2)+5*nef+n+15


#OUTPUT
#
#x,y,w,n,p,which,q,maxit,match,nef  are untouched
#spar	for each element of spar:
# 	if spar was 0 and dof was 0, then spar is that spar 
#			that minimized gcv
#	if spar was 0 and dof > 0, then spar is that which achieves dof
#dof	the dof of the fitted smooth. Note: even if dof was given
#		as 4, it will be returned as say 3.995 which is what
#		spar produces
#etal	double length n linear component of the fit
#s	double n by q nonlinear part of the smooth functions
#eta	double length n fitted values
#beta	double length p linear coefficients
#       So, the centered fitted functions are:
#			 b(j)*(x(i,j)-mean(x(.,j)) +s(i,j)
#		where j is an element of which
#var	double n by q 
#	if ifvar was .true.
#		the unscaled variance elements for the NONLINEAR
#		and UNIQUE part of s, in the order of sort(unique(x))
#		var is lev(i)/w(i) -h(i)/w where h(i) is the hat element from
#		the simple weighted least squares fit. This is  used in gamcov
#
#nit	number of iterations used
#qr etc the qr is returned

implicit double precision(a-h,o-z)
logical ifvar
integer npetc(7),iter
integer n,p,q,which(*),match(*),nef(*),nit,maxit,qrank,qpivot(*)
double precision x(*),y(*),w(*),spar(*),dof(*),
			etal(*),s(*),eta(*),beta(*),var(*),tol,
			qr(*),qraux(*),effect(*),work(*)
n=npetc(1)
p=npetc(2)
q=npetc(3)
ifvar=.false.
if(npetc(4)==1)ifvar=.true.
maxit=npetc(6)
qrank=npetc(7)

## 平滑化対象の変数の自由度を work に入れる
do i=1,q{work(i)=dof(i)}

## backf1 を呼び出す
call backf1(x,n,p,y,w,q,which,spar,dof,match,nef,
            etal,s,eta,beta,var,ifvar,tol,nit,maxit,
            qr,qraux,qrank,qpivot,effect,work(q+1),work(q+n+1),
            work(q+2*n+1),work(q+3*n+1),work(q+4*n+1))

npetc(7)=qrank
return
end
```

##### backf1

```{fortran}
#### backf1
subroutine backf1(x,n,p,y,w,q,which,spar,dof,match,nef,
			etal,s,eta,beta,var,ifvar,tol,nit,maxit,
			qr,qraux,qrank,qpivot,effect,z,old,sqwt,sqwti,work)
implicit double precision(a-h,o-z)
logical ifvar
integer n,p,q,which(q),match(n,q),nef(q),nit,maxit,qrank,qpivot(p)
double precision x(n,p),y(n),w(n),spar(q),dof(q),
			etal(n),s(n,q),eta(n),beta(p),var(n,q),tol,
			qr(n,p),qraux(p),effect(n),work(*)
double precision z(*),old(*),dwrss,ratio
double precision sqwt(n),sqwti(n)
logical anyzwt
double precision deltaf, normf,onedm7
integer job,info

onedm7=1d-7
job=1101;info=1
if(q==0)maxit=1
ratio=1d0

### weight の平方根をとって逆数にする
# fix up sqy's for weighted problems.
anyzwt=.false.
do i=1,n{
	if(w(i)>0d0){
		sqwt(i)=dsqrt(w(i)) ## Fortranの組み込み関数。sqrt()
		sqwti(i)=1d0/sqwt(i) ## weight の逆数
	}
	else{
		sqwt(i)=0d0
		sqwti(i)=0d0
		anyzwt=.true.
		}
	}

# if qrank > 0 then qr etc contain the qr decomposition
# else bakfit computes it. 
if(qrank==0){
	do i=1,n{
		do j=1,p{
			### 重みを乗じた x を生成
			qr(i,j)=x(i,j)*sqwt(i)
			}
		}
	do j=1,p{qpivot(j)=j} ### なんかピボット

	### どこで定義されてる？
	### https://github.com/cran/gam/blob/master/inst/ratfor/linear.r
	### QR分解
	call dqrdca(qr,n,n,p,qraux,qpivot,work,qrank,onedm7)
	}
do i=1,n{
	### eta（fitted value）に s(i,j) を加算する
	#s	double n by q nonlinear part of the smooth functions
	#		used as starting values. the linear part is
	#		irrelevant
	eta(i)=0d0
	for(j=1;j<=q;j=j+1){
		eta(i)=eta(i)+s(i,j)
		}
	}
nit=0
while ((ratio > tol )&(nit < maxit)){
	# first the linear fit
	deltaf=0d0
	nit=nit+1
	do i=1,n{
		z(i)=(y(i)-eta(i))*sqwt(i)
		old(i)=etal(i)
	}
#	call dqrsl1(qr,dq,qraux,qrank,sqz,one,work(1),etal,two,three)
#job=1101 -- computes fits, effects and beta
	### 最小二乗法を当てはめる
	### https://github.com/wch/r-source/blob/trunk/src/appl/dqrsl.f
	call dqrsl(qr,n,n,qrank,qraux,z,work(1),effect(1),beta,
		work(1),etal,job,info)

# now unsqrt the fits
#Note: we dont have to fix up the zero weights till the end, since their fits
#are always immaterial to the computation

	### 重みの逆数で戻す
	do i=1,n{
		etal(i)=etal(i)*sqwti(i)
		}

	### ここで平滑化対象の変数についてループ
	# now a single non-linear backfitting loop 
	for(k=1;k<=q;k=k+1){
		j=which(k)
		do i=1,n{
			### s を格納
			old(i)=s(i,k)
			### 残差に対して s を加算。理由はわからない
			z(i)=y(i)-etal(i)-eta(i)+old(i)
		}
                ### df は 0 にリセットされてしまう
				# this uses spar to set smoothing after iteration 1
                if(nit>1){dof(k)=0d0}
		
		### splsm を呼びだす
		call splsm(x(1,j),z,w,n,match(1,k),nef(k),spar(k),
			dof(k),s(1,k),s0,var(1,k),ifvar,work)
		do i=1,n{
			### eta を更新
			eta(i)=eta(i)+s(i,k)-old(i)
			### etal を更新
			### s0 は double weighted mean
			etal(i)=etal(i)+s0
			}
		deltaf=deltaf+dwrss(n,old,s(1,k),w)
		}
	normf=0d0
	do i=1,n{
		normf=normf+w(i)*eta(i)*eta(i)
		}
	if(normf>0d0){
		ratio=dsqrt(deltaf/normf)
		}
	 else {ratio = 0d0}
#         call DBLEPR("ratio",-1,ratio,1)
	}
#now package up the results
do j=1,p {work(j)=beta(j)}
do j=1,p {beta(qpivot(j))=work(j)}
if(anyzwt){
	do i=1,n {
		if(w(i) <= 0d0){
			etal(i)=0d0
			do j=1,p{
				etal(i)=etal(i)+beta(j)*x(i,j)
				}
			}
		}
	}
		
do i=1,n
	eta(i)=eta(i)+etal(i)
	
do j=1,q {
	call unpck(n,nef(j),match(1,j),var(1,j),old)
	do i=1,n {var(i,j)=old(i)}
	}

return
end

```





----- 以下は必要になったら -----



```{r}
### gam.fit に戻ってきた
fitqr <- fit$qr
xxnames <- xnames[fitqr$pivot]
nr <- min(sum(good), nvars)
if (nr < nvars) {
    Rmat <- diag(nvars)
    Rmat[1:nr, 1:nvars] <- fitqr$qr[1:nr, 1:nvars]
}
else Rmat <- fitqr$qr[1:nvars, 1:nvars]
Rmat <- as.matrix(Rmat)
Rmat[row(Rmat) > col(Rmat)] <- 0
dimnames(Rmat) <- list(xxnames, xxnames)
names(fit$residuals) <- ynames
names(mu) <- ynames
names(eta) <- ynames

### eta and mu
fit$additive.predictors <- eta
fit$fitted.values <- mu
names(fit$weights) <- ynames
names(fit$effects) <- c(xxnames[seq(len = fitqr$rank)], rep.int("", 
    sum(good) - fitqr$rank))
if (length(fit$smooth) > 0) 
    fit$smooth.frame <- smooth.frame[smooth.labels]
wtdmu <- if (a$intercept) 
    sum(weights * y)/sum(weights)
else linkinv(offset)
nulldev <- sum(dev.resids(y, wtdmu, weights))
n.ok <- nobs - sum(weights == 0)
nulldf <- n.ok - as.integer(a$intercept)
rank <- n.ok - fit$df.residual
aic.model <- aic(y, nobs, mu, weights, new.dev) + 2 * rank
if (!is.null(fit$smooth)) {
    nonzeroWt <- (wz > 0)
    nl.chisq <- gam.nlchisq(fit$qr, fit$residuals, wz, fit$smooth)
}
else nl.chisq <- NULL
fit <- c(fit, list(R = Rmat, rank = fitqr$rank, family = family, 
    deviance = new.dev, aic = aic.model, null.deviance = nulldev, 
    iter = iter, prior.weights = weights, y = y, df.null = nulldf, 
    nl.chisq = nl.chisq))
fit
}
```

#### 




#### gam()の残り

```{r}
    ### offset が指定されており intercept 項がある場合
    if (length(offset) && attr(mt, "intercept") > 0) {
        fit$null.dev <- glm.fit(x = X[, "(Intercept)", drop = FALSE], 
            y = Y, weights = weights, offset = offset, family = family, 
            control = control[c("epsilon", "maxit", "trace")], 
            intercept = TRUE)$deviance
    }
    if (model) 
        fit$model <- mf
    fit$na.action <- attr(mf, "na.action")
    if (x) 
        fit$x <- X
    if (!y) 
        fit$y <- NULL
    fit <- c(fit, list(call = call, formula = formula, terms = mt, 
        data = data, offset = offset, control = control, method = method, 
        contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
            mf)))
    class(fit) <- c("Gam", "glm", "lm")
    if (!is.null(fit$df.residual) && !(fit$df.residual > 0)) 
        warning("Residual degrees of freedom are negative or zero.  This occurs when the sum of the parametric and nonparametric degrees of freedom exceeds the number of observations.  The model is probably too complex for the amount of data available.")
    fit
}
```









```{r}
# fit <- lm(wage ~ poly(age, 4), data = Wage)
# coef(summary(fit))
# tmp <- head(cbind(Wage$age, poly(Wage$age, 4)))
# tmp
# fit2 <- lm(wage ~ poly(age, 4, raw = T), data = Wage)
# coef(summary(fit2))
# tmp2 <- head(cbind(Wage$age, poly(Wage$age, 4, raw = T)))
# tmp2
# tmp2[, 2]^2
# tmp2[, 2]^3
# tmp2[, 2]^4
```













```{r}
agelims <- range(Wage$age)
age.grid <- seq(from = agelims[1], to = agelims[2])
preds <- predict(fit, newdata = list(age = age.grid), se = TRUE)
se.bands <- cbind(preds$fit + 2 * preds$se.fit, preds$fit - 2 * preds$se.fit)
par(mfrow = c(1, 1), mar = c(4.5, 4.5, 1, 1), oma = c(0, 0, 4, 0))
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Quad Polynomial", outer = T)
lines(age.grid, preds$fit, lwd = 2, col = "blue")
matlines(age.grid, se.bands, lwd = 1, col = "blue", lty = 3)
```




```{r}
library(splines)
```



```{r}
plot(Wage$age, ns(Wage$age))
```


```{r}
par(mfrow = c(2, 2), cex = .5)
plot(ns(Wage$age, df = 4)[, 1], Wage$wage)
plot(ns(Wage$age, df = 4)[, 2], Wage$wage)
plot(ns(Wage$age, df = 4)[, 3], Wage$wage)
plot(ns(Wage$age, df = 4)[, 4], Wage$wage)
```



```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Smooth spline")
fit <- smooth.spline(Wage$age, Wage$wage, df = 16)
fit2 <- smooth.spline(Wage$age, Wage$wage, cv = TRUE)
fit2$df
lines(fit, col = "red", lwd = 2)
lines(fit2, col = "blue", lwd = 2)
legend("topright", legend = c("16 DF", "6.8 DF"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```

```{r}
plot(Wage$age, Wage$wage, xlim = agelims, cex = .5, col = "darkgrey")
title("Loess")
fit = loess(wage ~ age, span = .2, data = Wage)
fit2 = loess(wage ~ age, span = .5, data = Wage)
lines(age.grid, predict(fit, data.frame(age = age.grid)),
      col = "red", lwd = 2)
lines(age.grid, predict(fit2, data.frame(age = age.grid)),
      col = "blue", lwd = 2)
legend("topright", legend = c("Span = 0.2", "Span = 0.5"),
       col = c("red", "blue"), lty = 1, lwd = 2, cex = .8)
```



```{r}
gam1 <- lm(wage ~ ns(year, 4) + ns(age, 5) + education, data = Wage)
coef(summary(gam1))
```

```{r}
plot(gam1)
```

```{r}
library(gam)
```

```{r}
gam.m3 <- gam(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.m3, se = TRUE, col = "blue")
```

`gam1` は `lm` で当てはめているが `plot.Gam` が利用できる

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam1, se = TRUE, col = "red")
```


平滑化スプラインを使う場合は `lm` ではなく `gam` を使わないとまともに計算できない

```{r}
gam.m4 <- lm(wage ~ s(year, 4) + s(age, 5) + education, data = Wage)
```
```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.m4, se = TRUE, col = "red")
```


```{r}
gam.lo <- gam(wage ~ s(year, 4) + lo(age, span = 0.7) + education,
              data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot.Gam(gam.lo, se = TRUE, col = "blue")
```


```{r}
gam.lo.i <- gam(wage ~ lo(year, age, span = 0.5) + education,
                data = Wage)
```

```{r}
# install.packages("akima")
library(akima)
```

```{r}
plot(gam.lo.i)
```


```{r}
gam.lr <- gam(I(wage > 250) ~ year + s(age, 5) + education,
              family = "binomial", data = Wage)
```

```{r}
par(mfrow = c(1, 3))
plot(gam.lr, se = TRUE, col = "blue")
```

```{r}
gam.lr.s <- gam(I(wage > 250) ~ year + s(age, 5) + education,
                family = "binomial", data = Wage, 
                subset = (education != "1. < HS Grad"))
par(mfrow = c(1, 3))
plot(gam.lr.s, se = TRUE, col = "blue")
```


モデルオブジェクトが `smooth` を持つか
```{r}
is.null(gam.m4$smooth)
```

```{r}
is.null(gam.m3$smooth)
```


新規データに対してはSEは出せない

```{r}
nd <- head(Wage, 5)
predict(gam.m3, nd, se.fit = TRUE)
```



まずは `predict.glm` で予測値を求める。当然答えは異なる。

```{r}
predict.glm(gam.m3, nd)
predict.Gam(gam.m3, nd)
```


使用している変数で model.frame を作成する

```{r}
Terms <- delete.response(gam.m3$terms)
model.frame(Terms, nd)
```


```{r}
!is.null(cl <- attr(Terms, "dataClasses"))
```

```{r}
smooth.frame <- model.frame(Terms, nd, na.action = na.fail, 
                            xlev = gam.m3$xlevels)
.checkMFClasses(cl, smooth.frame)
```


モデルオブジェクトから平滑化された説明変数の列名を取ってくる。
上で作った `smooth.frame` ではなく、モデルオブジェクトに格納された
`smooth.frame` なので注意。

```{r}
nrows <- nrow(nd)
smooth.labels <- names(gam.m3$smooth.frame)
n.smooths <- length(smooth.labels)
pred.s <- array(0, c(nrows, n.smooths), list(row.names(smooth.frame), 
            smooth.labels))
pred.s
```



```{r}
terms <- labels(gam.m3)
smooth.labels[match(smooth.labels, terms, 0) > 0]
```

モデルオブジェクトの `smooth.frame` において該当する列の "call" アトリビューションを取り出す
```{r}
TT <- "s(year, 4)"
Call <- attr(gam.m3$smooth.frame[[TT]], "call")
Call
```

上記にオプションを追加する。 `Call` は `call` クラスであり、
List における各要素にオプションを持つ感じ。

```{r}
Call$xeval <- substitute(smooth.frame[[TT]], list(TT = TT))
Call
```


データの各点の重み w と、上で作った z を渡して `gam.s` を呼ぶ。
`data` オブジェクトの代わりにモデルオブジェクトの `smooth.frame` を渡す。
`spar` はスムージングパラメータ、 `df` は平滑化の自由度。 `df` が指定されている場合はこちらが使われる

```{r}
w <- gam.m3$weights
z <- gam.m3$residuals + gam.m3$smooth[, TT]
# pred.s[, TT] <- eval(Call)
pred.s <- gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```


`df` を指定した状態で `spar` を変えても予測値は変わらないはず。

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 4, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 4, xeval = smooth.frame[[TT]])
```

`df` を0にすると `spar` が使われる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 0.8, df = 0, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1.2, df = 0, xeval = smooth.frame[[TT]])
```

`df` を1以上で変化させると予測値が変わる

```{r}
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 2, xeval = smooth.frame[[TT]])
gam.s(gam.m3$smooth.frame[[TT]], z, w, spar = 1, df = 4, xeval = smooth.frame[[TT]])
```
